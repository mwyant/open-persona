package main

import (
	"bytes"
	"context"
	"crypto/rand"
	"encoding/base64"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"time"
)

func main() {
	projectDir := flag.String("project-dir", "../open-persona", "Path to the open-persona repository")
	envFile := flag.String("env-file", "", "Path to write env file (default: <project-dir>/.env.launcher)")
	composeFile := flag.String("compose-file", "", "Path to docker-compose.yml (default: <project-dir>/docker-compose.yml)")
	noBrowser := flag.Bool("no-browser", false, "Do not open the browser when ready")
	timeout := flag.Int("timeout", 120, "Timeout in seconds for health checks")
	flag.Parse()

	absProj, err := filepath.Abs(*projectDir)
	if err != nil {
		fatal("resolve project dir", err)
	}

	if *envFile == "" {
		*envFile = filepath.Join(absProj, ".env.launcher")
	}
	if *composeFile == "" {
		*composeFile = filepath.Join(absProj, "docker-compose.yml")
	}

	fmt.Println("Project dir:", absProj)
	fmt.Println("Compose file:", *composeFile)
	fmt.Println("Env file:", *envFile)

	// 1. Check docker
	if _, err := exec.LookPath("docker"); err != nil {
		fatal("docker not found in PATH; please install Docker", err)
	}
	// Ensure docker compose is available
	if err := runCommand(nil, "docker", "compose", "version"); err != nil {
		fatal("docker compose check failed", err)
	}

	// 2. Ensure compose file exists
	if _, err := os.Stat(*composeFile); os.IsNotExist(err) {
		fatal("compose file not found", fmt.Errorf("%s", *composeFile))
	}

	// 3. Create env file if missing
	if _, err := os.Stat(*envFile); os.IsNotExist(err) {
		fmt.Println("Creating env file:", *envFile)
		if err := writeEnvFile(*envFile); err != nil {
			fatal("write env file", err)
		}
	} else {
		fmt.Println("Env file already exists, will use it (not overwriting)")
	}

	// 4. Launch docker compose
	fmt.Println("Starting docker compose stack...")
	upArgs := []string{"compose", "--project-directory", absProj, "--env-file", *envFile, "up", "--build", "-d"}
	if err := runCommand(nil, "docker", upArgs...); err != nil {
		fatal("docker compose up failed", err)
	}

	// 5. Wait for health
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(*timeout)*time.Second)
	defer cancel()

	checks := []string{
		"http://localhost:3000/health",
		"http://localhost:8000/healthz",
	}

	fmt.Println("Waiting for services to become healthy (timeout", *timeout, "s)")
	for _, url := range checks {
		if err := waitForHTTP(ctx, url); err != nil {
			fatal("health check failed for "+url, err)
		}
		fmt.Println(url, "OK")
	}

	fmt.Println("All services healthy.")

	if !*noBrowser {
		openBrowser("http://localhost:3000")
	}

	fmt.Println("Launcher finished.")
}

func fatal(msg string, err error) {
	fmt.Fprintf(os.Stderr, "ERROR: %s: %v\n", msg, err)
	os.Exit(1)
}

func runCommand(env []string, name string, args ...string) error {
	cmd := exec.Command(name, args...)
	if env != nil {
		cmd.Env = append(os.Environ(), env...)
	}
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func writeEnvFile(path string) error {
	// Minimal env contents; do not overwrite existing secrets.
	content := new(bytes.Buffer)
	// Add defaults used by docker-compose
	fmt.Fprintln(content, "# Generated by open-persona-launcher")
	fmt.Fprintln(content, "OPEN_PERSONA_DEFAULT_OPENAI_API_KEY=")
	fmt.Fprintln(content, "OPEN_PERSONA_DEFAULT_ANTHROPIC_API_KEY=")
	fmt.Fprintln(content, "OPEN_PERSONA_DEFAULT_OPENROUTER_API_KEY=")
	// generate a short random key for WEBUI_SECRET_KEY fallback
	k, err := randomBase64(12)
	if err == nil {
		fmt.Fprintf(content, "WEBUI_SECRET_KEY=%s\n", k)
	}

	f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0600)
	if err != nil {
		return err
	}
	defer f.Close()
	_, err = io.Copy(f, content)
	return err
}

func randomBase64(n int) (string, error) {
	b := make([]byte, n)
	_, err := rand.Read(b)
	if err != nil {
		return "", err
	}
	return base64.RawURLEncoding.EncodeToString(b), nil
}

func waitForHTTP(ctx context.Context, url string) error {
	tick := time.NewTicker(1 * time.Second)
	defer tick.Stop()
	client := http.Client{Timeout: 2 * time.Second}
	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-tick.C:
			resp, err := client.Get(url)
			if err == nil && resp != nil {
				io.Copy(io.Discard, resp.Body)
				resp.Body.Close()
				if resp.StatusCode >= 200 && resp.StatusCode < 500 {
					return nil
				}
			}
		}
	}
}

func openBrowser(url string) {
	var cmd *exec.Cmd
	switch runtime.GOOS {
	case "linux":
		cmd = exec.Command("xdg-open", url)
	case "darwin":
		cmd = exec.Command("open", url)
	case "windows":
		cmd = exec.Command("rundll32", "url.dll,FileProtocolHandler", url)
	default:
		fmt.Println("Open browser not supported on this OS")
		return
	}
	if err := cmd.Start(); err != nil {
		fmt.Println("Failed to open browser:", err)
	}
}
